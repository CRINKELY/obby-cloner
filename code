local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local ver = "1.003"

local Events = game.ReplicatedStorage.Events

local PropertyTypes = {
	["PaintObject"] = {
		"CanCollide",
		"CastShadow",
		"Color",
		"Material",
		"Reflectance",
		"Transparency",
		"Shape",
	},
	
	["SpecialPaintObject"] = {
		"Surface", -- Enum, FrontSurface
		"Slipperiness", -- part.CustomPhysicalProperties.FrictionWeight
		"Water" -- part.AttributeLinks.Water
	},
	
	["EffectTypes"] = { -- Fire, ImageLabel.ImageLabel, PointLight, SelectionBox, ParticleEmitter, ProximityPrompt, Smoke, Sparkles, SpotLight, SurfaceLight, TextLabel.TextLabel, Texture, VideoFrame.VideoFrame
		["fire"] = "Fire",
		["image"] = "ImageLabel",
		["light"] = "PointLight",
		["outline"] = "SelectionBox",
		["particles"] = "ParticleEmitter",
		["prompt"] = "ProximityPrompt",
		["smoke"] = "Smoke",
		["sparkles"] = "Sparkles",
		["spotlight"] = "Spotlight",
		["surfacelight"] = "SurfaceLight",
		["text"] = "TextLabel",
		["texture"] = "Texture",
		["video"] = "VideoFrame"
	},
	
	["EffectProperties"] = {
		["fire"] = {
			"Color",
			"Heat",
			"SecondaryColor",
			"Size"
		},
		["image"] = {
			"BackgroundColor3",
			"BackgroundTransparency",
			"Brightness",
			"Face",
			"Image",
			"ImageColor3",
			"ImageTransparency",
			"LightInfluence",
			"Position",
			"Size"
		},
		["light"] = {
			"Brightness",
			"Color",
			"Range",
			"Shadows"
		},
		["outline"] = {
			"Color3",
			"LineThickness",
			"SurfaceColor3",
			"SurfaceTransparency",
			"Transparency"
		},
		["particles"] = {
			"Color",
			"LightEmission",
			"LightInfluence",
			"Orientation",
			"Size",
			"Squash",
			"Texture", -- must be converted from number to string
			"Transparency",
			"ZOffset",
			"EmissionDirection",
			"Lifetime",
			"Rate",
			"RotSpeed",
			"Speed",
			"SpreadAngle",
			"Shape",
			"ShapeInOut",
			"ShapePartial",
			"ShapeStyle",
			"Acceleration",
			"Drag",
			"LockedToPart"
		},
		["prompt"] = {
			"ActionText",
			"BackgroundColor", -- in attributes
			"BackgroundTransparency", -- in attributes
			"GamepadKeyCode",
			"HoldDuration",
			"KeyboardKeyCode",
			"MaxActivationDistance",
			"ObjectText",
			"RequiresLineOfSight"
		},
		["smoke"] = {
			"Color",
			"Opacity",
			"RiseVelocity",
			"Size"
		},
		["sparkles"] = {
			"SparkleColor"
		},
		["spotlight"] = {
			"Angle",
			"Brightness",
			"Color",
			"Range",
			"Shadows"
		},
		["surfacelight"] = {
			"Angle",
			"Brightness",
			"Color",
			"Face",
			"Range",
			"Shadows"
		},
		["text"] = {
			"BackgroundTransparency",
			"Brightness",
			"Face",
			"Font",
			"LightInfluence",
			"Position",
			"RichText",
			"Size",
			"SizingMode",
			"Text",
			"TextColor3",
			"TextStrokeColor3",
			"TextStrokeTransparency",
			"TextTransparency"
		},
		["texture"] = {
			"Color3",
			"Face",
			"OffsetStudsU",
			"OffsetStudsV",
			"StudsPerTileU",
			"StudsPerTileV",
			"Texture", -- must be converted from number to string
			"Transparency"
		},
		["video"] = {
			"Face",
			"Video"
		}
	}
}

local PartFolders = {
	"Buttons",
	"Character Models",
	"Conveyors",
	"Moving Parts",
	"Music Zones",
	"Parts",
	"Pressure Plates",
	"Push Parts",
	"Quiz Parts",
	"Special",
	"Spin Parts",
	"Timed Parts",
	"Truss"
}

if not game.ReplicatedStorage:FindFirstChild("SavedObbies") then
	local SavedObbies = Instance.new("Folder")
	SavedObbies.Name = "SavedObbies"
	SavedObbies.Parent = game.ReplicatedStorage
end

if not game.ReplicatedStorage:FindFirstChild("PartQueue") then
	local PartQueue = Instance.new("Folder")
	PartQueue.Name = "PartQueue"
	PartQueue.Parent = workspace
	
	for i, folder in pairs(PartFolders) do
		local Folder = Instance.new("Folder")
		Folder.Name = folder
		Folder.Parent = PartQueue
	end
end

function notification(title, content, duration, image) -- "shield-alert" for errors
	Rayfield:Notify({
		Title = title or "Obby Cloner",
		Content = content or "",
		Duration = duration or 6.5,
		Image = image or "bell",
	})
end

function GetSelectedObby()
	local function SelectedObby()
		for i, obby in pairs(workspace.Obbies:GetChildren()) do
			if obby.Area.Area:FindFirstChild("BorderSelection") and obby.Area.Area.BorderSelection.Visible then
				return obby.Name
			end
		end
		
		return nil
	end
	
	local plr = game.Players:FindFirstChild(tostring(SelectedObby()))
	
	if plr == nil then 
		return nil, nil
	end

	return plr, workspace.Obbies:FindFirstChild(plr.Name).GetObby.Gate.CFrame - Vector3.new(0, 3, 0) - Vector3.new(0, 0.5, 0) + (workspace.Obbies:FindFirstChild(plr.Name).GetObby.Gate.CFrame.LookVector * 0.5)
end

function ClonePartProperties(part: BasePart)
	local plr, obbyCFrame = GetSelectedObby()

	if plr == nil then
		notification("Error:", "No obby is currently being edited.", 6.5, "shield-alert")
		if true then return end
	end

	local Obby = workspace.Obbies:FindFirstChild(plr.Name)
	local Parts = Obby.Items:FindFirstChild(part.Parent.Name)

	local args = {
		[1] = part.Name,
		[2] = obbyCFrame + (obbyCFrame.LookVector * 10) + Vector3.new(0, 2, 0)
	}

	Events.AddObject:InvokeServer(unpack(args))
	
	local NewPart = Parts:GetChildren()[1]
	
	task.wait()

	local args = {
		[1] = { -- parts
			[1] = { -- part
				[1] = NewPart,
				[2] = CFrame.new(part.Position) * CFrame.Angles(math.rad(part.Rotation.X), math.rad(part.Rotation.Y), math.rad(part.Rotation.Z)), -- pos, rot
				[3] = Vector3.new(part.Size.X, part.Size.Y, part.Size.Z) -- size
			},
		},
	}

	Events.MoveObject:InvokeServer(unpack(args))

	for i, property in pairs(PropertyTypes.PaintObject) do
		if part.ClassName == "MeshPart" and property == "Shape" then continue end
		
		local value = part[property]
		
		print(property, typeof(value))
		
		if typeof(value) == "Enums" or typeof(value) == "Enum" or typeof(value) == "EnumItem" and typeof(value) ~= "boolean" then
			value = value.Name
		end
		
		print("Passed enum check")
		
		local args = {
			[1] = { -- parts
				[1] = NewPart
			},
			[2] = property,
			[3] = value
		}

		Events.PaintObject:InvokeServer(unpack(args))
		
		for i = 1, 3, 1 do
			task.wait()
		end
	end
	
	for i, property in pairs(PropertyTypes.SpecialPaintObject) do
		local value = nil
		
		if property == "Water" then
			if part:FindFirstChild("AttributeLinks") ~= nil and part.AttributeLinks:FindFirstChild("Water") ~= nil then
				value = true
			end
		elseif property == "Surface" then
			value = part.FrontSurface.Name
		elseif property == "Slipperiness" then
			if part.CustomPhysicalProperties ~= nil then
				value = part.CustomPhysicalProperties.FrictionWeight
			end
		end

		local args = {
			[1] = { -- parts
				NewPart
			},
			[2] = property,
			[3] = value
		}

		Events.PaintObject:InvokeServer(unpack(args))
		
		for i = 1, 3, 1 do
			task.wait()
		end
	end
	
	for effectType, effectIndex in pairs(PropertyTypes.EffectTypes) do
		if part:FindFirstChild(effectIndex) ~= nil then
			local effectOrigin = part:FindFirstChild(effectIndex)
			
			if part[effectIndex]:FindFirstChild(effectIndex) ~= nil then
				effectOrigin = part[effectIndex][effectIndex]
			end
			
			local args = {
				[1] = { -- parts
					NewPart
				},
				[2] = effectType,
				[3] = "Default",
			}

			Events.EffectObject:InvokeServer(unpack(args))
			
			for i, effectProperty in pairs(PropertyTypes.EffectProperties[effectType]) do
				local propertyOrigin = effectOrigin
				
				local parentOriginProperties = {
					"SizingMode",
					"LightInfluence",
					"Brightness",
					"Face"
				}
				
				local parentOriginTypes = {
					"text",
					"image",
					"video"
				}
				
				if table.find(parentOriginProperties, effectProperty) and table.find(parentOriginTypes, effectType) then
					propertyOrigin = effectOrigin.Parent
				end
				
				local value = propertyOrigin[effectProperty]
				
				if typeof(propertyOrigin[effectProperty]) == "Enums" or "Enum" or "EnumItem" then
					value = propertyOrigin[effectProperty].Name
				end
				
				if effectProperty == "Texture" then
					value = tostring(propertyOrigin[effectProperty])
				end
				
				if table.find(part:GetAttributes(), effectProperty) and effectType == "prompt" then
					value = part:GetAttributes()[table.find(part:GetAttributes(), effectProperty)]
				end
				
				local args = {
					[1] = { -- parts
						NewPart
					},
					[2] = effectType,
					[3] = effectProperty,
					[4] = propertyOrigin[effectProperty]
				}

				Events.EffectObject:InvokeServer(unpack(args))
			end
		end
		
		for i = 1, 3, 1 do
			task.wait()
		end
	end
	
	for i, behaviour: ValueBase in pairs(part:GetChildren()) do
		if behaviour:IsA("ValueBase") then
			local args = {
				[1] = { -- parts
					NewPart
				},
				[2] = behaviour.Name, -- found inside of the part as objectvalues
				[3] = part[behaviour.Name].Value,
			}

			Events.BehaviourObject:InvokeServer(unpack(args))
		end
		
		for i = 1, 3, 1 do
			task.wait()
		end
	end
	
	for i = 1, 3, 1 do
		task.wait()
	end
	
	NewPart.Parent = workspace.PartQueue:FindFirstChild(Parts.Name)
	
	task.wait()
end

local function getPlayerNames()
	local plrs = {}

	for i, plr in pairs(game.Players:GetPlayers()) do
		table.insert(plrs, plr.Name)
	end

	return plrs
end

local function getObbyNames()
	local obbies = {}
	local plr, cframe = GetSelectedObby()

	if plr == nil then return nil end
	if game.ReplicatedStorage.SavedObbies:FindFirstChild(plr.Name) == nil then return nil end

	for i, obby in pairs(game.ReplicatedStorage.SavedObbies:FindFirstChild(plr.Name):GetChildren()) do
		table.insert(obbies, obby.Name)
	end

	return obbies
end

-- GUI

local Window = Rayfield:CreateWindow({
	Name = "Obby Cloner - v"..ver,
	Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
	LoadingTitle = "Obby Creator - Obby Cloner",
	LoadingSubtitle = "by alte055",
	Theme = "DarkBlue", -- Check https://docs.sirius.menu/rayfield/configuration/themes

	DisableRayfieldPrompts = false,
	DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

	ConfigurationSaving = {
		Enabled = false,
		FolderName = nil, -- Create a custom folder for your hub/game
		FileName = "Obby Cloner"
	},

	Discord = {
		Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
		Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
		RememberJoins = true -- Set this to false to make them join the discord every time they load it up
	},

	KeySystem = false, -- Set this to true to use our key system
	KeySettings = {
		Title = "Untitled",
		Subtitle = "Key System",
		Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
		FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
		SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
		GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
		Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
	}
})

local Saver = Window:CreateTab("Saver", "save")

PlayerDropdown = Saver:CreateDropdown({
	Name = "Players",
	Options = getPlayerNames(),
	CurrentOption = {game.Players.LocalPlayer.Name},
	MultipleOptions = false,
	Flag = "Dropdown", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Options)
		Options = getPlayerNames()
	end,
})

local SaveCooldown = false
ButtonSave = Saver:CreateButton({
	Name = "Save Obby",
	Callback = function()
		local success, errors = pcall(function()
			if SaveCooldown then
				notification("Error:", "Saving is currently on cooldown. Please wait for cooldown to end.", 2, "shield-alert")
				if true then return end
			end

			SaveCooldown = true

			notification("Obby Cloner", "Saving obby...", 4, "bell")
			ButtonSave:Set("Saving...")

			local player = game.Players:FindFirstChild(PlayerDropdown.CurrentOption[1])

			if workspace.Obbies:FindFirstChild(player.Name) then
				if not game.ReplicatedStorage.SavedObbies:FindFirstChild(player.Name) then
					local Folder = Instance.new("Folder")
					Folder.Name = player.Name
					Folder.Parent = game.ReplicatedStorage.SavedObbies
				end
			else
				notification("Error:", "Player selected currently doesn't exist. Please choose another player.", 6.5, "shield-alert")
				if true then return end
			end

			if not game.ReplicatedStorage.SavedObbies[player.Name]:FindFirstChild(workspace.Obbies:FindFirstChild(player.Name).IdVAL.Value) then
				local Obby = workspace.Obbies:FindFirstChild(player.Name):Clone()
				Obby.Name = Obby.IdVAL.Value
				Obby.Parent = game.ReplicatedStorage.SavedObbies:FindFirstChild(player.Name)
			else
				notification("Notification:", "Obby has already been cloned previously!", 6.5, nil)
			end

			task.wait()
			SaveCooldown = false
			notification("Obby Cloner", "Obby has been saved!", 4, "bell")
			ButtonSave:Set("Save Obby")
		end)
		
		warn("Errors:",errors)
	end,
})

local Cloner = Window:CreateTab("Cloner", "copy")

ClonerInput = Cloner:CreateInput({
	Name = "Target",
	CurrentValue = "",
	PlaceholderText = "Input target ObbyId...",
	RemoveTextAfterFocusLost = false,
	Flag = "Input1",
	Callback = function(Text)
		local obbyNames = getObbyNames()
		
		if obbyNames ~= nil and table.find(obbyNames, Text) then
			notification("Obby Cloner", `ObbyId set to {Text}.`, 4, "bell")
		else
			notification("Error:", "Obby currently selected cannot be found or doesn't exist. Please reselect a ObbyId.", 6.5, "shield-alert")
			ClonerInput:Set("")
		end
	end,
})

local CloneCooldown = false
ButtonClone = Cloner:CreateButton({
	Name = "Clone Obby",
	Callback = function()
		local success, errors = pcall(function()
			local player, cframe = GetSelectedObby()

			if CloneCooldown then
				notification("Error:", "Obby is currently being cloned. Please wait for obby to fully clone to use again.", 6.5, "shield-alert")
				if true then return end
			end

			if not game.ReplicatedStorage.SavedObbies:FindFirstChild(player.Name) or not game.ReplicatedStorage.SavedObbies[player.Name]:FindFirstChild(ClonerInput.CurrentValue) then
				notification("Error:", "Obby currently selected cannot be found or doesn't exist. Please reselect a ObbyId.", 6.5, "shield-alert")
				if true then return end
			end

			CloneCooldown = true
			notification("Obby Cloner", "Cloning...", 4, "bell")

			local Obby = game.ReplicatedStorage.SavedObbies[player.Name]:FindFirstChild(ClonerInput.CurrentValue)

			local BlacklistedFolders = { -- unsupported parts, will be changed later
				"Spin Parts",
				"Moving Parts"
			}

			local CalculatedPartsSize = 0
			local PartsCloned = 0

			for i, partsFolder in pairs(Obby:GetChildren()) do
				if table.find(BlacklistedFolders, partsFolder.Name) then continue end

				for i, part in pairs(partsFolder:GetChildren()) do
					CalculatedPartsSize += 1
				end
			end

			for i, partsFolder in pairs(Obby.Items:GetChildren()) do
				if table.find(BlacklistedFolders, partsFolder.Name) then continue end

				for i, part in pairs(partsFolder:GetChildren()) do
					ClonePartProperties(part)
					ButtonClone:Set(`Cloning... ( {math.round(PartsCloned/CalculatedPartsSize * 10000) / 100}% )`)

					PartsCloned += 1
				end
			end

			notification("Obby Cloner", "Obby has been cloned! Enjoy :)", 4, "bell")
			CloneCooldown = false
			ButtonClone:Set("Clone Obby")
		end)
		
		warn("Errors:",errors)
	end,
})

local ObbiesSaved = Cloner:CreateParagraph({Title = "Cloned Obbies:", Content = "None"})

notification("Obby Cloner", "Obby Cloner has loaded!", 4, "bell")

while task.wait() do
	local obbyNames = getObbyNames()
	
	if obbyNames == nil then
		ObbiesSaved:Set({Title = "Cloned Obbies:", Content = "None"})
		task.wait()
		continue
	end
	
	ObbiesSaved:Set({Title = "Cloned Obbies:", Content = table.concat(getObbyNames(), ",\n")})
end
